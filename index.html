<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>גלובוס תלת־ממדי עם ריבוע גדול להעלאת תמונות</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      width: 100%;
      user-select: none;
      direction: rtl;
      font-family: Arial, sans-serif;
      color: #0f0;
    }
    #upload {
      position: fixed;
      top: 50%;
      right: 40px;
      transform: translateY(-50%);
      width: 280px;
      height: 280px;
      border: 2px dashed #0f0;
      border-radius: 16px;
      font-size: 140px;
      color: #0f0;
      line-height: 276px;
      text-align: center;
      cursor: pointer;
      background-size: cover;
      background-position: center center;
      transition: background 0.3s ease;
      user-select: none;
      z-index: 10;
    }
    #fileInput {
      display: none;
    }
    canvas {
      position: fixed;
      top: 50%;
      right: 320px; /* מקום לריבוע */
      transform: translateY(-50%);
      width: calc(100vw - 360px);
      height: calc(100vh - 40px);
      display: block;
      border-radius: 8px;
      background-color: #000;
      touch-action: none; /* למנוע גלילה במגע */
    }
    @media (max-width: 500px) {
      #upload {
        width: 160px;
        height: 160px;
        font-size: 80px;
        line-height: 156px;
        right: 20px;
      }
      canvas {
        right: 200px;
        width: calc(100vw - 220px);
        height: calc(100vh - 40px);
      }
    }
    #rotateMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 2em;
      text-align: center;
      padding: 20px;
      display: none;
      user-select: none;
      z-index: 100;
      background: rgba(0,0,0,0.8);
      border-radius: 12px;
      max-width: 90vw;
    }
  </style>
</head>
<body>
  <div id="upload" title="לחץ להעלות תמונה">+</div>
  <input type="file" id="fileInput" accept="image/*" />
  <div id="rotateMessage">הפוך את המסך לרוחב</div>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.150.1';

    const uploadDiv = document.getElementById('upload');
    const fileInput = document.getElementById('fileInput');
    const rotateMessage = document.getElementById('rotateMessage');

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 3, 5);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const defaultTexture = new THREE.TextureLoader().load('https://upload.wikimedia.org/wikipedia/commons/8/83/Equirectangular_projection_SW.jpg');
    const material = new THREE.MeshPhongMaterial({ map: defaultTexture });
    material.side = THREE.DoubleSide;
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    let isDragging = false;
    let previousPosition = { x: 0, y: 0 };

    function getTouchPos(e) {
      const touch = e.touches[0] || e.changedTouches[0];
      return { x: touch.clientX, y: touch.clientY };
    }

    // עכבר - desktop
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousPosition = { x: e.clientX, y: e.clientY };
    });
    renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
    renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const deltaX = e.clientX - previousPosition.x;
      const deltaY = e.clientY - previousPosition.y;
      sphere.rotation.y += deltaX * 0.005;
      sphere.rotation.x += deltaY * 0.005;
      previousPosition = { x: e.clientX, y: e.clientY };
    });

    // זום בגלגל העכבר במחשב - איטי יותר
    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.003;  // הקצב קטן יותר להגדלה איטית
      if (camera.position.z < 1.5) camera.position.z = 1.5;
      if (camera.position.z > 10) camera.position.z = 10;
    }, { passive: false });

    // מגע - mobile/touch - סיבוב
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        const pos = getTouchPos(e);
        previousPosition = { x: pos.x, y: pos.y };
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchend', (e) => {
      if (e.touches.length === 0) {
        isDragging = false;
        lastPinchDistance = null;
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchcancel', (e) => {
      isDragging = false;
      lastPinchDistance = null;
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const pos = getTouchPos(e);
        const deltaX = pos.x - previousPosition.x;
        const deltaY = pos.y - previousPosition.y;
        sphere.rotation.y += deltaX * 0.005;
        sphere.rotation.x += deltaY * 0.005;
        previousPosition = { x: pos.x, y: pos.y };
      } else if (e.touches.length === 2) {
        handlePinchZoom(e);
      }
    }, { passive: false });

    // זום במגע - pinch zoom
    let lastPinchDistance = null;
    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function handlePinchZoom(e) {
      const distance = getDistance(e.touches);
      if (lastPinchDistance !== null) {
        const delta = distance - lastPinchDistance;

        // נעדכן את מיקום המצלמה (z) לפי השינוי (מגדילים ומקטינים)
        camera.position.z -= delta * 0.01;
        // נעשה בקרה על הטווח כדי לא לצאת מהגבולות
        if (camera.position.z < 1.5) camera.position.z = 1.5;
        if (camera.position.z > 10) camera.position.z = 10;
      }
      lastPinchDistance = distance;
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    function hasCompass(ctx, width, height) {
      const compassWidth = 150;
      const compassHeight = 150;
      const imageData = ctx.getImageData(width - compassWidth, 0, compassWidth, compassHeight);
      const data = imageData.data;
      for(let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        const a = data[i+3];
        if(a > 128 && (g > 100 || b > 100) && r < 100) {
          return true;
        }
      }
      return false;
    }

    function removeCompass(ctx, width, height) {
      const compassWidth = 150;
      const compassHeight = 150;
      ctx.clearRect(width - compassWidth, 0, compassWidth, compassHeight);
    }

    uploadDiv.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(ev) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          if(hasCompass(ctx, canvas.width, canvas.height)) {
            removeCompass(ctx, canvas.width, canvas.height);
            console.log("מצפן זוהה ומחקנו אותו");
          } else {
            console.log("לא זוהה מצפן, נטען כמו שהוא");
          }

          const newTexture = new THREE.CanvasTexture(canvas);
          newTexture.needsUpdate = true;

          material.map = newTexture;
          material.needsUpdate = true;

          uploadDiv.style.backgroundImage = `url(${canvas.toDataURL()})`;
          uploadDiv.textContent = '';
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    function onResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (height > width) {
        rotateMessage.style.display = 'block';
        uploadDiv.style.display = 'none';
        renderer.domElement.style.display = 'none';
      } else {
        rotateMessage.style.display = 'none';
        uploadDiv.style.display = 'block';
        renderer.domElement.style.display = 'block';

        let uploadWidth = 280;
        let uploadRight = 40;
        let canvasRight = uploadRight + uploadWidth + 20;

        if (width < 500) {
          uploadWidth = 160;
          uploadRight = 20;
          canvasRight = uploadRight + uploadWidth + 20;
        }

        renderer.setSize(width - canvasRight, height);
        camera.aspect = (width - canvasRight) / height;
        camera.updateProjectionMatrix();

        renderer.domElement.style.position = 'fixed';
        renderer.domElement.style.top = '50%';
        renderer.domElement.style.right = canvasRight + 'px';
        renderer.domElement.style.transform = 'translateY(-50%)';
        renderer.domElement.style.height = height + 'px';
        renderer.domElement.style.width = (width - canvasRight) + 'px';

        uploadDiv.style.top = '50%';
        uploadDiv.style.right = uploadRight + 'px';
        uploadDiv.style.transform = 'translateY(-50%)';
        uploadDiv.style.width = uploadWidth + 'px';
        uploadDiv.style.height = uploadWidth + 'px';
        uploadDiv.style.fontSize = (uploadWidth * 0.5) + 'px';
        uploadDiv.style.lineHeight = (uploadWidth - 4) + 'px';
      }
    }

    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    onResize();
  </script>
</body>
</html>
